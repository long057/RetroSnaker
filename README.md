# RetroSnaker
javascript game

贪吃蛇游戏
-----

### 初始化游戏

#### 初始化游戏舞台

将整个游戏的舞台分成一个一个的小方块，利用二维数组生成方块，组成游戏的舞台

#### 初始化地板和墙壁

地板和墙壁由不同颜色的方块组成，每个方块都自带一个touch方法，显示如果这个方块被触碰到后会蛇的转态，碰触墙壁死亡，碰触地板继续移动

#### 初始化食物

食物采用单例模式，每次生成的食物都是第一个生成的那个食物。

单例模式：将第一次生成的对象进行保存，以后每次调用的时候如果是第一次则重新生成，如果不是第一次则返回第一次保存的结果

#### 初始化蛇

蛇包含蛇头和蛇身，蛇头采用单例模式，游戏开始蛇身有两节。蛇头和蛇身通过链表的next和last联系在一起。

蛇有运动的方向，可以通过键盘改变蛇的运动方向。蛇运动的时候预判蛇运动方向的下一块方块被碰触到时蛇的状态， 如果是死亡，则游戏结束。如果是继续运动则继续运动，蛇头移动到下一个方块的位置，身体长度不变。如果是食物则生成新的蛇身，蛇头的位置是下一个方块的位置，蛇的身体增加一节。

#### 工厂模式

统一管理方块的生产，基类是功能是生成每个方块的宽高和坐标位置。 子类构造函数都写在构造工厂的原型上，例:SquareFactory.prototype.Food = function () {}; SnakeFactory工厂通过create方法传入不同的方块类型来返回不同的方块。 工厂用来统一管理各个不同的子类， 实际还是由子类的构造函数来构造实例。  

```
function SquareFactory() {};// 工厂 
SquareFactory.create = function () { 
    // .....代码 
    return new SquareFactory.prototype\[type\](); 
}
```

#### 策略模式

#### 是一系列的算法定义，将每一个算法封装起来，想可以相互替换。

蛇运动的下一个方块进行预判，如果碰触改方块，蛇将会发生什么转态。将这些状态写成一个一个的函数，能更好的增加或删除各种功能，扩展性非常的好

```
// 策略方法集合 
snake.strategies = { 
  'move': function () {
      // 蛇头位置移动到下一个方块，在原来蛇头的位置新增一个蛇身。将蛇尾减掉 
   },
   'die': function () {
      // 游戏结束，显示得分 
    }, 
    'eat': function () { 
       // 蛇头移动到下一个反馈的位置，在原蛇头的位置新增一个蛇身，蛇身增加一节。
     }
   }
  ```
